## Numpy 연산
 연산을 통한 결과 , 주피터 노트 이용 ,행렬연산 특화
 ```python
 import numpy as np
t_a=np.arange(1,11)
t_a.sum()
# >> 55
# reshape 배열의 차원의 크기를 변경
t_a=np.arange(1,13).reshape(3,4)#첫 매개변수 값이 고차원임-> 2차원3개원소 1차원 4개원소를 가짐 
t_a
'''
 >>array([[ 1,  2,  3,  4],
          [ 5,  6,  7,  8],
          [ 9, 10, 11, 12]])
'''
t_a.sum(axis=0)#2차원
#>>array([15, 18, 21, 24])
t_a.sum(axis=1)#1차원
#>>array([10, 26, 42])

#np.vstack 결합된 배열이 만들어짐. 결합원소의 길이가 같아야함
v_a=np.array([1,2,3])
v_a_1=np.array([4,5,6])
'''
>>array([[1, 2, 3],
       [4, 5, 6]])
'''
#넘파이는 사칙연산이 가능

## 내적 (행렬의 곱) 가로와 세로는 일치해야한다!@!!!@!!
x=np.arange(1,7).reshape(2,3)#저차원이 3
y=np.arange(1,7).reshape(3,2)#저차원이 2
print(x)
print(y)
np.dot(x,y)#내적
x.dot(y)#내적 방법2
'''
x=[[1 2 3]
  [4 5 6]]
y=[[1 2]
  [3 4]
  [5 6]]
array([[22, 28],
       [49, 64]])
'''
```
## 인덱싱 관련
```python
x=np.arange(1,11)
x
'''
>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
'''
l=np.array([0,5,9,0,0,0])
x[l]
'''
>array([ 1,  6, 10,  1,  1,  1])#각 인덱스 값에 해당하는 리스트 가져옴
'''
#팬시 인덱스
x=x.reshape(2,-1)#array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])을 2개의원소를 갖는 2차원, -1개의 원소를 갖는 1차원(콤마가 사라져서 출력됨)
i_1=np.array([0,1])#i_1은 [ 1  2  3  4  5]의 2를 가져옴
i_0=np.array([1,0])#i_0은 [ 6  7  8  9 10]의 6을 가져옴
print(x)
x[i_0,i_1]# x[ 6 , 2 ]
'''
>[[ 1  2  3  4  5]
 [ 6  7  8  9 10]]

>array([6, 2])
'''
## 슬라이싱
x_l=np.array([x,x,x])

'''
>>>
array([[[ 1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10]],

       [[ 1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10]],

       [[ 1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10]]])

'''
x_l[:,:1,::2]#3차원 전치 리스트에/2차원의 0인덱스에/1차원의 처음부터 끝까지 2간격으로 슬라이싱
'''
>>>
array([[[1, 3, 5]],

       [[1, 3, 5]],

       [[1, 3, 5]]])


'''


```